A linker?? (http://linker.iecc.com/)
plt infect persistence
reflexify
the debugger ui for web
something to learn dynamic linking in linux
--> sé cómo van los simbolos en windows, pero no en linux
en PE los simbolos son por module, en elf parecen ser globales
EXPORTS en PE si pero en ELF NO SÉ!! COMPARATIVE APPROACH
http://phrack.org/issues/56/7.html
https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-42444.html#scrolltoc
https://www.uclibc.org/docs/psABI-x86_64.pdf
http://www.skyfree.org/linux/references/ELF_Format.pdf
https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI
https://gist.github.com/DhavalKapil/2243db1b732b211d0c16fd5d9140ab0b <-- read last paragraph
http://man7.org/linux/man-pages/man3/dladdr.3.html
http://www.muppetlabs.com/~breadbox/software/elfkickers.html
http://bottomupcs.sourceforge.net/csbu/x3824.htm
https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html
http://sco.com/developers/gabi/latest/ch5.dynamic.html#got

code caves in the elf, dynamic relocation info <.. NO! IT'S STILL IN MEMORY

whatsapp read

GOT PLT article?



0x55d132226000 base
mike@mike-laptop:~/Desktop/pltgot$ readelf -r /bin/bash | grep exit
000000306e28  00c000000007 R_X86_64_JUMP_SLO 0000000000000000 exit@GLIBC_2.2.5 + 0
|-> 0x55d132226000 + 0x000000306e28 = 0x55d13252ce28

r_offset for exe is va of place to fix, relative to base if pie

----DYNAMIC RELOCS-----
from r_info extract type with ELF64_R_TYPE(r_info) and sym table index with ELF64_R_SYM(...)
SUPONGO que el sym table index es el indice del simbolo en la tabla de simbolos dinamicos.
https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-1235.html#scrolltoc
|- PUNTO 5 "The relocation table is identified by the DT_JUMPREL dynamic section entry"

DT_JMPREL
    The address of relocation entries that are associated solely with the procedure linkage table. See Procedure Linkage Table (Processor-Specific). The separation of these relocation entries enables the runtime linker to ignore these entries when the object is loaded with lazy binding enabled. This element requires the DT_PLTRELSZ and DT_PLTREL elements also be present.

	DT_PLTREL
    Indicates the type of relocation entry to which the procedure linkage table refers, either DT_REL or DT_RELA. All relocations in a procedure linkage table must use the same relocation. See Procedure Linkage Table (Processor-Specific). This element requires a DT_JMPREL element also be present.

DT_PLTRELSZ
    The total size, in bytes, of the relocation entries associated with the procedure linkage table. See Procedure Linkage Table (Processor-Specific).

----DYNAMIC SYMBOLS-------


As mentioned before, symbol lookup is a complicated process, I'll give a simplified description.

For every loaded object RTLD (the runtime dynamic linker) keeps a list of loaded objects called the "lookup scope". Every scope contains pointers to all the loaded objects (the binary and all loaded libraries), but the order of objects can differ between different scopes. What is constant is that the binary is the first object in every scope.

When the RTLD has to resolve a symbol, it first checks for which object it needs to perform the relocation. Was the lookup caused in the binary itself or in one of the loaded libraries. Then it gets the lookup scope for that object, and iterates through every object in it.

For each object it looks for the needed symbol is in the dynamic symbol table. In case of a match it just uses that symbol value for the relocation, otherwise it continues its search looking at the next object in the scope.
vdso vsyscall


////// SOLO ALGUNAS NOTAS, NO HACER CASO
APUNTES MIOS, NO HACER CASO

en windows no hace falta ptrace stop para manipular el espacio de memoria de un proceso remoto.
en windows la size de todo esta bien definido y no depende de si el binario esta sstriped o no.
tampoco hay que tocar el archivo en disco para mirar el section header.

un nivel de indireccion para resolver los imports.
en widnows no hace falta (aunque se puede hacer) infectar los imports
porque puedes hacer CreateRemoteThreadEx y VirtualAllocEx

------------
leo el elf header de memoria pero no debería siquiera estar allí

-----
mike@mike-laptop:~/Desktop/pltgot$ sudo ./foo 25747
[+] base address of pid 25747 is 0x400000
[+] DYNAMIC section at 0x600e20 (size 464 bytes)
[+] Dynamic relocation table for PLT GOT at 0x400430 (120 bytes) DT_RELA
[+] Dynamic symbol table at 0x4002b8
[+] Dynamic string table at 0x400378 (size 88 bytes)
[+] Estimated size of the PLT GOT: 64 bytes (8 entries)
[+] Estimated size of dynamic symbol table: 192 bytes (8 entries)


[+] ---- DUMP OF PLT GOT OF TARGET ----
[0]	0x601018:	0x7f1e1e8329c0	(sym. #1)	puts
[1]	0x601020:	0x7f1e1e8978e0	(sym. #2)	getpid
[2]	0x601028:	0x4004f6	(sym. #3)	system
[3]	0x601030:	0x7f1e1e816e80	(sym. #4)	printf
[4]	0x601038:	0x7f1e1e8968e0	(sym. #7)	pause





